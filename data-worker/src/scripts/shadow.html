<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Fetching...</title>
        <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
        <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
        <script src="https://www.unpkg.com/mapbox-gl-shadow-simulator/dist/mapbox-gl-shadow-simulator.umd.min.js"></script>
        <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
        <style>
            body {
                margin: 0;
                padding: 0;
            }
            html,
            body,
            #map {
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="map"></div>
    </body>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const { timestamp, data } = window.inputData;
            const BUILDING_ZOOM = 15;
            const boundingBoxes = data;
            const time = new Date(timestamp * 1000); // Date expects unix timestamp in milliseconds

            const blocks = [];
            const blockMetaDataArr = [];
            let totalNumPoints = 0;

            for (let i = 0; i < boundingBoxes.length; i++) {
                const cells = boundingBoxes[i].cells;
                const currBlock = [];
                const currBlockMetaData = [];
                cells.forEach((cell) => {
                    const currCell = [];
                    const cellMetaData = [];
                    const edges = cell.edges;

                    edges.forEach((edge) => {
                        const edgeInfo = { edgeId: edge.edgeId, numSubEdges: 0, numPoints: 0 };
                        const points = edge.points;
                        const currEdge = [];
                        let idx = 1;
                        while (idx < points.length) {
                            let curr = points[idx];
                            let prev = points[idx - 1];
                            let route = turf.lineString([prev, curr]);
                            let length = turf.length(route);
                            let numPoints = Math.ceil(length / 5);
                            let step = length / numPoints;
                            let subEdgePoints = [];
                            for (let j = 0; j < numPoints; j++) {
                                let point = turf.along(route, step * j);
                                subEdgePoints.push(point.geometry.coordinates);
                            }
                            // sample one point anyway
                            if (numPoints < 1) {
                                numPoints = 1;
                                subEdgePoints = [prev];
                            }
                            currEdge.push(subEdgePoints);
                            edgeInfo.numSubEdges += 1;
                            edgeInfo.numPoints += numPoints;
                            totalNumPoints += numPoints;
                            idx += 1;
                        }
                        currCell.push(currEdge);
                        cellMetaData.push(edgeInfo);
                    });
                    currBlock.push(currCell);
                    currBlockMetaData.push(cellMetaData);
                });

                blocks.push(currBlock);
                blockMetaDataArr.push(currBlockMetaData);
            }
            // console.log('total number of points', totalNumPoints);

            let { minLon, maxLon, minLat, maxLat } = boundingBoxes[0].limits;
            let initialCenter = turf.center(turf.bboxPolygon([minLon, minLat, maxLon, maxLat]));

            mapboxgl.accessToken = window.MAPBOX_CRED;
            const map = new mapboxgl.Map({
                container: 'map',
                zoom: 15,
                center: initialCenter.geometry.coordinates,
                style: 'mapbox://styles/mapbox/streets-v11',
                hash: true,
            });

            const mapLoaded = (map) => {
                return new Promise((res, rej) => {
                    function cb() {
                        if (!map.loaded()) {
                            return;
                        }
                        map.off('render', cb);
                        res();
                    }

                    map.on('render', cb);
                    cb();
                });
            };

            map.on('load', async () => {
                const shadeMap = new ShadeMap({
                    apiKey: window.SHADEMAP_CRED,
                    date: time,
                    // color: '#ff0000',
                    // opacity: 1,
                    terrainSource: {
                        maxZoom: 15,
                        tileSize: 256,
                        getSourceUrl: ({ x, y, z }) => {
                            return `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`;
                        },
                        getElevation: ({ r, g, b, a }) => {
                            return r * 256 + g + b / 256 - 32768;
                        },
                        _overzoom: 18,
                    },
                    getFeatures: async () => {
                        await mapLoaded(map);
                        const buildingData = map
                            .querySourceFeatures('composite', { sourceLayer: 'building' })
                            .filter((feature) => {
                                return (
                                    feature.properties &&
                                    feature.properties.underground !== 'true' &&
                                    (feature.properties.height || feature.properties.render_height)
                                );
                            });
                        return buildingData;
                    },
                }).addTo(map);

                const blockOutputs = [];
                // console.log('total number of blocks ', blocks.length);

                for (let i = 0; i < blocks.length; i++) {
                    const cells = blocks[i];
                    const metaData = blockMetaDataArr[i];
                    const { minLon, maxLon, minLat, maxLat } = boundingBoxes[i].limits;

                    const bbox = [minLon, minLat, maxLon, maxLat];
                    const bboxPolygon = turf.bboxPolygon(bbox);
                    const center = turf.center(bboxPolygon);

                    const shadeMapLoaded = new Promise((res) => {
                        shadeMap.on('idle', res);
                    });

                    map.setCenter(center.geometry.coordinates).setZoom(BUILDING_ZOOM);
                    // new mapboxgl.Marker({ color: 'red' }).setLngLat(center.geometry.coordinates).addTo(map);
                    const mapboxLoaded = mapLoaded(map);

                    await Promise.all([mapboxLoaded, shadeMapLoaded]);

                    const blockOutput = await Promise.all(
                        cells.map(async (cell) => {
                            if (cell.length === 0) {
                                return [];
                            }

                            const locations = cell.flatMap((edge) =>
                                edge.flatMap((subEdge) =>
                                    subEdge.map((point) => ({
                                        lng: point[0],
                                        lat: point[1],
                                    })),
                                ),
                            );

                            const result = await shadeMap._generateShadeProfile({
                                locations,
                                dates: [time],
                                sunColor: [255, 255, 255, 255],
                                shadeColor: [0, 0, 0, 255],
                            });

                            return result;
                        }),
                    );

                    blockOutputs.push(blockOutput);
                }

                let aggregatedOutput = {};

                for (let i = 0; i < blockOutputs.length; i++) {
                    const blockOutput = blockOutputs[i];
                    const blockMetaData = blockMetaDataArr[i];

                    const outputArrFlat = Array.from(blockOutput)
                        .map((arr) => [...arr])
                        .flat();
                    // console.log('Resulted numPoints', outputArrFlat.length);

                    let outputIdx = 0;
                    for (let j = 0; j < blockMetaData.length; j++) {
                        const cellMetaData = blockMetaData[j];
                        for (let k = 0; k < cellMetaData.length; k++) {
                            let edgeInfo = cellMetaData[k];
                            let count = edgeInfo.numPoints * 4;
                            let start = outputIdx;
                            outputIdx += count;
                            let currEdge = outputArrFlat.slice(start, outputIdx);
                            let pointsInShade = 0;
                            for (let p = 0; p < currEdge.length; p += 4) {
                                if (currEdge[p] === 0) {
                                    pointsInShade += 1;
                                }
                            }
                            let shadePercentage = pointsInShade / edgeInfo.numPoints;
                            aggregatedOutput[edgeInfo.edgeId] = shadePercentage;
                        }
                    }
                }

                // console.log('Resulted edge count ', Object.keys(aggregatedOutput).length);

                window.outputData = aggregatedOutput;
            });
        });
    </script>
</html>
